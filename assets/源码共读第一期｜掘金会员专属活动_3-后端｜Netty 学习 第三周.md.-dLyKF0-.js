import{_ as a,c as s,o as e,X as i}from"./chunks/framework.a0KWhRid.js";const f=JSON.parse('{"title":"后端｜Netty 学习 第三周","description":"","frontmatter":{},"headers":[],"relativePath":"源码共读第一期｜掘金会员专属活动/3-后端｜Netty 学习 第三周.md","filePath":"源码共读第一期｜掘金会员专属活动/3-后端｜Netty 学习 第三周.md","lastUpdated":1729754194000}'),t={name:"源码共读第一期｜掘金会员专属活动/3-后端｜Netty 学习 第三周.md"},n=i(`<h1 id="后端-netty-学习-第三周" tabindex="-1">后端｜Netty 学习 第三周 <a class="header-anchor" href="#后端-netty-学习-第三周" aria-label="Permalink to &quot;后端｜Netty 学习 第三周&quot;">​</a></h1><h3 id="本章任务提供" tabindex="-1">本章任务提供 <a class="header-anchor" href="#本章任务提供" aria-label="Permalink to &quot;本章任务提供&quot;">​</a></h3><p><a href="https://juejin.cn/user/430664257374270" title="https://juejin.cn/user/430664257374270" target="_blank" rel="noreferrer">挖坑的张师傅</a></p><h3 id="领读员说" tabindex="-1">领读员说 <a class="header-anchor" href="#领读员说" aria-label="Permalink to &quot;领读员说&quot;">​</a></h3><blockquote><p>大家好，我是张师傅。为了能帮助到更多对源码感兴趣、想学会看源码、提升自己后端技术能力的同学。组织了大家一起学习源码共读活动。</p><p>我对各个中间件源码非常感兴趣，过去一段时间阅读了 MySQL、JVM、Nginx、Netty、Spring、Linux 内核相关的源码，也写过很多关于根据源码来定位问题的文章，详见我的掘金博客 <a href="https://juejin.cn/user/430664257374270" title="https://juejin.cn/user/430664257374270" target="_blank" rel="noreferrer">juejin.cn/user/430664…</a></p><p>对于 Java 后端的同学，Netty 的源码是非常经典的学习资料，它不仅包含了丰富的网络编程相关的知识，还在代码中展示了很多 Java 编程的高级技巧，是我们深入学习网络编程、理解事件驱动、高性能编程不可多得的经典。</p></blockquote><h2 id="任务说明" tabindex="-1">任务说明 <a class="header-anchor" href="#任务说明" aria-label="Permalink to &quot;任务说明&quot;">​</a></h2><p>后端任务在整个源码学习的过程中出现，和前端分离的子任务不同，本篇包含了多个学习任务，除了以学习任务为核心产出的笔记以外，在阅读源码的时候产出的其他笔记也可参与本次活动。</p><h2 id="学习任务" tabindex="-1">学习任务 <a class="header-anchor" href="#学习任务" aria-label="Permalink to &quot;学习任务&quot;">​</a></h2><p>Netty 的数据读写是以 ByteBuf 为单位的，它的结构如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eabb3b13370401c93ef1485cc1e20a4~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="image.png"></p><p>任务 1：阅读 ByteBuf 的代码，总结它与 Java NIO 中的 ByteBuffer 有什么区别？</p><p>ByteBuf 可以通过扩展底层的数组来实现自动扩展。当缓冲区的容量不足以存储新的数据时，ByteBuf 就会自动扩展底层数组的大小，以便容纳更多的数据</p><p>任务 2：Netty 中的 ByteBuf 源码是如何实现自动扩展的，请写出伪代码</p><p>任务 3：阅读相关代码，ByteBuf 是线程安全的吗？</p><p>任务 4：为什么 ByteBuf 读写需要加锁？</p><p>ByteBuf 支持多种内存管理模型，包括堆内内存（heap buffer）、堆外内存（direct buffer）和内存池（pooled buffer）。</p><p>任务 5：堆外内存、堆外内存、内存池的优缺点有哪些，分别用在哪些场景</p><p>任务 6：下面的分配方式分别对应上面的哪种类型</p><div class="language-ini vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ByteBufAllocator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">allocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = ByteBufAllocator.DEFAULT</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ByteBuf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = allocator.heapBuffer()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ByteBufAllocator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">allocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = ByteBufAllocator.DEFAULT</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ByteBuf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = allocator.directBuffer()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ByteBufAllocator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">allocator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = ByteBufAllocator.DEFAULT</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ByteBuf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">buffer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = allocator.pooledBuffer()</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>ByteBuf 的读写操作是非阻塞的，阅读相关代码。</p><p>任务 7：非阻塞特性是通过 ByteBuf 的什么原理实现的</p><p><a href="https://juejin.cn/book/7169108142868365349/section/7172389086643093537" target="_blank" rel="noreferrer">原文地址</a></p>`,22),l=[n];function p(r,h,k,o,c,u){return e(),s("div",null,l)}const y=a(t,[["render",p]]);export{f as __pageData,y as default};
